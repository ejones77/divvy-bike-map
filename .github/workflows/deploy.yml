name: Deploy

on:
  push:
    branches: [main]

env:
  REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  AWS_REGION: ${{ secrets.AWS_REGION }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Setup ECR repository
      run: aws ecr describe-repositories --repository-names $REPOSITORY || aws ecr create-repository --repository-name $REPOSITORY
    
    - name: Build and push images
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        docker compose build api ml
        
        push_image() {
          local service=$1
          local image_name="divvy-bike-map-${service}"
          
          docker tag ${image_name}:latest $ECR_REGISTRY/$REPOSITORY:${service}-latest
          docker tag ${image_name}:latest $ECR_REGISTRY/$REPOSITORY:${service}-$IMAGE_TAG
          
          docker push $ECR_REGISTRY/$REPOSITORY:${service}-latest
          docker push $ECR_REGISTRY/$REPOSITORY:${service}-$IMAGE_TAG
        }
        
        push_image api
        push_image ml
    - name: Deploy to EC2 via SSM
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Execute deployment via SSM using the deployment script
        COMMAND_ID=$(aws ssm send-command \
          --instance-ids "${{ secrets.EC2_INSTANCE_ID }}" \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "export ECR_REGISTRY=\"'"$ECR_REGISTRY"'\"",
            "export IMAGE_TAG=\"'"$IMAGE_TAG"'\"",
            "export REPOSITORY=\"'"${{ secrets.ECR_REPOSITORY }}"'\"",
            "export GITHUB_REPOSITORY=\"'"${{ github.repository }}"'\"",
            "export AWS_ACCESS_KEY_ID=\"'"${{ secrets.AWS_ACCESS_KEY_ID }}"'\"",
            "export AWS_SECRET_ACCESS_KEY=\"'"${{ secrets.AWS_SECRET_ACCESS_KEY }}"'\"",
            "export AWS_REGION=\"'"${{ secrets.AWS_REGION }}"'\"",
            "export PRODUCTION_DB_URL=\"'"${{ secrets.PRODUCTION_DB_URL }}"'\"",
            "export MODEL_S3_BUCKET=\"'"${{ secrets.MODEL_S3_BUCKET }}"'\"",
            "export GRAFANA_ADMIN_PASSWORD=\"'"${{ secrets.GRAFANA_ADMIN_PASSWORD }}"'\"",
            "curl -fsSL https://raw.githubusercontent.com/'"${{ github.repository }}"'/main/scripts/deploy.sh | bash"
          ]' \
          --query 'Command.CommandId' \
          --output text)
        
        echo "Deployment command sent with ID: $COMMAND_ID"
        
        # Wait for command completion with timeout and better error handling
        echo "Waiting for deployment to complete..."
        MAX_WAIT=600  # 10 minutes timeout
        WAIT_INTERVAL=10
        ELAPSED=0
        
        while [ $ELAPSED -lt $MAX_WAIT ]; do
          STATUS=$(aws ssm get-command-invocation \
            --command-id $COMMAND_ID \
            --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
            --query 'Status' \
            --output text 2>/dev/null || echo "InProgress")
          
          echo "Command status: $STATUS (${ELAPSED}s elapsed)"
          
          if [ "$STATUS" = "Success" ] || [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then
            break
          fi
          
          sleep $WAIT_INTERVAL
          ELAPSED=$((ELAPSED + WAIT_INTERVAL))
        done
        
        # Always show the command output and errors for debugging
        echo "=== COMMAND OUTPUT ==="
        aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
          --query 'StandardOutputContent' \
          --output text
        
        echo "=== COMMAND ERRORS ==="
        ERROR_OUTPUT=$(aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
          --query 'StandardErrorContent' \
          --output text)
        echo "$ERROR_OUTPUT"
        
        echo "=== FINAL COMMAND STATUS ==="
        FINAL_STATUS=$(aws ssm get-command-invocation \
          --command-id $COMMAND_ID \
          --instance-id ${{ secrets.EC2_INSTANCE_ID }} \
          --query 'Status' \
          --output text)
        echo "$FINAL_STATUS"
        
        # Check if deployment was successful
        if [ "$FINAL_STATUS" != "Success" ]; then
          echo "Deployment failed with status: $FINAL_STATUS"
          if [ -n "$ERROR_OUTPUT" ] && [ "$ERROR_OUTPUT" != "None" ]; then
            echo "Error details shown above"
          fi
          exit 1
        fi
        
        echo "Deployment completed successfully via SSM"